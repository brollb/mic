/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Mon Sep 23 2019 15:44:50 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'text!./jupyter.py.ejs',
    'superagent',
    'ejs',
    'q',
    'common/util/random'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    JupyterTemplate,
    superagent,
    ejs,
    Q,
    Random) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of SendGraphToJupyter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin SendGraphToJupyter.
     * @constructor
     */
    function SendGraphToJupyter() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    SendGraphToJupyter.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    SendGraphToJupyter.prototype = Object.create(PluginBase.prototype);
    SendGraphToJupyter.prototype.constructor = SendGraphToJupyter;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    SendGraphToJupyter.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        var self = this,
            core = this.core,
            META = this.META,
            path2name = {},
            graphNode = this.activeNode,
            renderObject = {
                projectId: self.projectId,
                path: core.getPath(graphNode),
                token: 'None',
                nodes: [],
                edges: [],
                branchName: self.branchName
            },
            fileName = Random.generateGuid(),
            ipynb;


        core.loadChildren(graphNode)
            .then(function (children) {
                var deferred = Q.defer();
                // Processing the nodes.
                children.forEach(function (child) {
                    if (core.isTypeOf(child, META.Node)) {
                        renderObject.nodes.push({name: core.getAttribute(child, 'name'), id: core.getRelid(child)});
                        path2name[core.getPath(child)] = core.getAttribute(child, 'name');
                    }
                });

                // Processing the edges.
                children.forEach(function (child) {
                    if (core.isTypeOf(child, META.Edge)) {
                        renderObject.edges.push(
                            {
                                from: path2name[core.getPointerPath(child, 'src')],
                                to: path2name[core.getPointerPath(child, 'dst')]
                            }
                        );
                    }
                });

                // Acquiring token so jupyter could run a plugin
                superagent.get('/api/user/token').end(function (err, res) {
                    if (res.ok || res.body.message === 'Authentication is turned off') {
                        if (res.ok) {
                            renderObject.token = '\'' + res.body.webgmeToken + '\'';
                        }
                        // Generating the ipynb content
                        ipynb = JSON.parse(ejs.render(JupyterTemplate, renderObject));
                        deferred.resolve();
                    } else {
                        deferred.reject(new Error('unknown authentication pattern, cannot proceed!'));
                    }
                });
                return deferred.promise;
            })
            .then(function () {
                // Creating empty notebook
                return superagent
                    .post('/jupyter/api/contents')
                    .send({type: 'notebook'});
            })
            .then(function (res) {
                if (!res.ok || res.status !== 201) {
                    throw new Error('Unable to create new notebook!', res.status);
                }

                // Renaming notebook
                return superagent
                    .patch('/jupyter/api/contents/' + res.body.name)
                    .send({
                        name: fileName + '.ipynb',
                        path: fileName + '.ipynb'
                    });
            })
            .then(function (res) {
                if (!res.ok || res.status !== 200) {
                    throw new Error('Unable to rename new notebook!', res.status);
                }

                // Patching data to notebook
                return superagent
                    .put('/jupyter/api/contents/' + fileName + '.ipynb')
                    .send({
                        type: 'notebook',
                        content: ipynb
                    });
            })
            .then(function (res) {
                if (!res.ok || res.status !== 200) {
                    throw new Error('Unable to upload notebook data!', res.status);
                }

                core.setAttribute(graphNode, 'ipynb', fileName);
                return self.save('Created jupyter notebook [' + fileName + '].');
            })
            .then(function () {
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                self.result.setSuccess(true);
                self.logger.error(err.stack);
                callback(err, self.result);
            });
        //render the cell
        //POST to create untitled notebook
        //PATCH to rename it
        //PUT to update content
        /*
        POST: /api/contents/work
        {"type": "notebook"}
        PATCH /api/contents/work/Untitled(i).ipynb
        {
    "name": "enyim.ipynb",
    "path": "work/enyim.ipynb"
}
        PUT: /api/contents/work/enyim.ipynb
        {
    "name": "enyim.ipynb",
    "path": "work/enyim.ipynb",
    "last_modified": "2019-09-23T23:10:57.073326Z",
    "created": "2019-09-23T23:14:58.081829Z",
    "content": {
        "cells": [{
            "cell_type": "code",
            "execution_count": 0,
            "metadata": {},
            "outputs": [],
            "source": [
                "import json\n",
                "import networkx as nx\n",
                "import requests as req\n","\n",
                "def shift_pos(pos, offsetx, offsety):\n",
                "  for coord in pos:\n",
                "    coord[0] += offsetx\n",
                "    coord[1] += offsety\n",
                "  return pos\n",
                "def send_to_webgme(coordinates):\n",
                "  print(\"TODO call plugin to update model\")\n",
                "  return\n","\n",
                "G = nx.Graph()\n"
            ]
        }],
        "metadata": {},
        "nbformat": 4,
        "nbformat_minor": 2
    },
    "format": "json",
    "mimetype": null,
    "size": 72,
    "writable": true,
    "type": "notebook"
}
         */
    };

    return SendGraphToJupyter;
});
